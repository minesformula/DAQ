#include "include/sensorProcess.h"

GPS::GPS(double firstX, double firstY, double secondX, double secondY){
    initialX = firstX;
    initialY = firstY;
    direction = 0;

    //Calculating slope of line perpendicular to the two given points (the second point should be generated by the car moving 
    //outside the field of potential GPS error).
    slope = -(secondY-firstY)/(secondX-firstX);
    YInt = firstX/(secondY-firstY) - firstY;

    secondX = secondX - firstX;
    secondY = secondY - firstY;
    firstX = firstY = 0;

    //Saving direction in Radians. Eventually slope should be easily calculated using direction.
    //This would allow a direction sensor to replace the need for a second data point.
    if (secondX < 0){
        direction += M_PI/2;
        secondX *= -1;

        if (secondY < 0){
            direction += M_PI/2;
            secondY *= -1;
        }
    } else if (secondY < 0){
        direction += (3*M_PI/2);
        secondY *= -1;
    }

    direction += atan(secondY/secondX);

    prevCheck = lapMoment = high_resolution_clock::now();
    currLapTime = prevLapTime = 0;
    delta = 0;

    passed = false;
}

void GPS::addPoint(double inX, double inY){
    _dataX.push_back(inX);
    _dataY.push_back(inY);
}

//Function that checks if a lap has occured and updates member variables if so.
bool GPS::recordLap(){
    auto timeSinceCheck = duration_cast<microseconds>(high_resolution_clock::now() - prevCheck);
    prevCheck = high_resolution_clock::now();

    const double firstX = _dataX[_dataX.size() - 2];
    const double firstY = _dataY[_dataY.size() - 2];
    const double secondX = _dataX[_dataX.size() - 1];
    const double secondY = _dataY[_dataY.size() - 1];

    double secondSlope = (secondX-firstX)/(secondY-firstY);
    double secondYInt = firstX/(secondY-firstY) - firstY;

    //Calculating intercept between two lines. If the intercept is between our two points then we have passed the initial
    //line. The car will pass the initial line twice per lap.
    double xValue = (YInt - secondYInt)/(secondSlope - slope);
    double yValue = (xValue * slope) + YInt;

    if (fmin(firstX, secondX) <= xValue <= fmax(firstX, secondX) && fmin(firstY, secondY) <= yValue <= fmax(firstY, secondY)){
        
        //If the car has completed a full lap. Predict when the car crossed the initial line and update member variables.
        //Please note this code will have to be modified to match the approximate length of the track since the line could 
        //be passed more than twice in a lap.
        if (passed){
            double ratio = sqrt(pow((xValue-firstX), 2), pow((yValue-firstY), 2))/sqrt(pow((secondX-firstX), 2), pow((secondY-firstY), 2));
            
            currLapTime += timeSinceCheck.count()*ratio;
            delta = currLapTime - prevLapTime;

            prevLapTime = currLapTime;
            currLapTime = timeSinceCheck.count()*(ratio-1);
            passed = false;

            _dataX.erase();
            _dataY.erase();

            return true;
        }

        passed = true;
    }

    currLapTime += timeSinceCheck.count();
    return false;
}

double GPS::getPrevLapTime(){
    return prevLapTime;
}

double GPS::getCurrLapTime(){
    return currLapTime;
}

double GPS::getDelta(){
    return delta;
}


Sensor::Sensor(){
    CANID = -1;
    process = nullptr;
}

Sensor::Sensor(unsigned int canIN, void functionIN (int)){
    CANID = canIN;
    process = functionIN;
}

void Sensor::processData(int value){
    process(value);
}